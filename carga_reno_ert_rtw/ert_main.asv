/*
 * File: ert_main.c
 *
 * Code generated for Simulink model 'carga_reno'.
 *
 * Model version                  : 1.20
 * Simulink Coder version         : 8.14 (R2018a) 06-Feb-2018
 * C/C++ source code generated on : Fri Dec 13 10:02:20 2019
 *
 * Target selection: ert.tlc
 * Embedded hardware selection: Intel->x86-64 (Windows64)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include <stddef.h>
#include <stdio.h>                     /* This ert_main.c example uses printf/fflush */
#include "carga_reno.h"                /* Model's header file */
#include "rtwtypes.h"
#include <wiringSerial.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>
#include <wiringPi.h>
//#include <ncurses.h>
//#include "libmcp3204.h"

/*
 * Associating rt_OneStep with a real-time clock or interrupt service routine
 * is what makes the generated code "real-time".  The function rt_OneStep is
 * always associated with the base rate of the model.  Subrates are managed
 * by the base rate from inside the generated code.  Enabling/disabling
 * interrupts and floating point context switches are target specific.  This
 * example code indicates where these should take place relative to executing
 * the generated code step function.  Overrun behavior should be tailored to
 * your application needs.  This example simply sets an error status in the
 * real-time model and returns from rt_OneStep.
 */

//Variables creadas por el programador



//Emulacion de panel
#define BUFFER_SIZE 1024
double Vg,Vc,n,Ns,T1,Voc_T1,Isc_T1,Isc_T2,T2,Voc_T2,Ics_T2,TaK,K0,IL_T1,IL,I0,I0_T1,Xv,dVdI_Voc,k,q,Rs,A,Vt_Ta,Ia;
double Suns,TaC,Va,Temp,Volt,Irra;

//Datos del txt
const char *delimiter_characters = "\t";
const char *filename = "perfiles_meteo_consum1/myData7_5min.txt";//"perfiles_meteo_consum/myData7_5min.txt";
FILE *input_file; //= fopen(filename, "r");
char buffer[BUFFER_SIZE];
char *last_token;
char *year;
char *day;
char *times;
char *outhum;
char *windspd;
char *rain;
char *solarrad2;
char *tempout2;
char *consumptp;
char *consumptq;
int contador;
int contador2=0;



//Ataques
#define BUFFER_SIZE 1024
const char *DoS = "ataqueDoS";
FILE *input_DoS;
char buffera[BUFFER_SIZE];
char *rDoS;

//------Entradas-------
//Carga
double i1=0.0;
double i3=0.0;
//MCP3204 ad_MCP3204;

//Renovables
double ipv=0.0;
//double vload3=0.0;
double Prefd=0.0;
double Qrefd=0.0;
double solarrad;
double tempout;
double potencia=0.0;
int fileDescriptor;
char error[55];

//------Salidas--------
//Carga
double Pm=0.0;
double Qm=0.0;
double Vload=0.0;
double min=5000;
double max=0.0;
double potencia=0.0;
double tiempo=0.0;

//Renovables
double i2=0.0;
double soc=0.0;
double Pm2=0.0;
double Qm2=0.0;
double duty_cyle=0.0;


//Comunicacion   ------------Falta cuadrar esta parte de la comunicacion con el arduino
#include <stdbool.h> 
#define MSGISIZE 26
int  bytes_read = 0;
int pinr=0;
int var=0;
char bufferAux;
char read_buffer[MSGISIZE];   /* Buffer to store the data received              */
int var1=0;
int var2=0;
int var3=0;
char var1s[7];
char var2s[7];
char var3s[7];
int fd;
int Vloada=0;
int Pma=0;
int Qma=0;
char buffer[8];

bool stringComplete = false;  // whether the string is complete
bool conti = true;
char inputCharArray[125];
char delim[] = ",";
char *ptr;
int j = 0;
char inChar;
char *Bio_CA;
char *Dies_CA;
char *EnAlt_CA;
int Bio = 0,Dies = 0,EnAlt = 0;

//===============================================================
//-------Variables para graficar
#include <math.h>
#define NUM_POINTS 100000
char * commandsForGnuplot[] = {"set title \"TITLEEEEE\"", "plot 'data.temp'"};
double xvals[NUM_POINTS];//= {1.0, 2.0, 3.0, 4.0, 5.0};
double yvals[NUM_POINTS];// = {5.0 ,3.0, 1.0, 3.0, 5.0};
FILE * temp;
FILE *	gnuplotPipe;
double in=0;
//===============================================================


int i;
int k;

// 39 datos
// Dt = 427us (idealmente) para 60Hz
int senw[] = {2048,	2377,	2697,	3000,	3278,
3525,	3733,	3898,	4015,	4081,
4094,	4055,	3963,	3822,	3634,
3406,	3143,	2851,	2538,	2213,
1883,	1558,	1245,	953,	690,
462,	274,	133,	41,	2,
15, 81,	198,	363,	571,
818, 1096,	1399,	1719};



//--------------Para RT-----------------
#include <time.h>
#include <sched.h>
//#include <wiringPi.h>

#define NSEC_PER_SEC    1000000000

//--------------------------------------


//===================  Para Pipes =========================
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define OUR_INPUT_FIFO_NAME "/tmp/dataC"

int our_input_fifo_filestream = -1;
int result;
char bufferPipe[128];
//=========================================================

//----------------------------Para RT------------------------------
/* using clock_nanosleep of librt */
extern int clock_nanosleep(clockid_t __clock_id, int __flags,
        __const struct timespec *__req,
        struct timespec *__rem);

/* the struct timespec consists of nanoseconds
 * and seconds. if the nanoseconds are getting
 * bigger than 1000000000 (= 1 second) the
 * variable containing seconds has to be
 * incremented and the nanoseconds decremented
 * by 1000000000.
 */
static inline void tsnorm(struct timespec *ts)
{
    while (ts->tv_nsec >= NSEC_PER_SEC) {
        ts->tv_nsec -= NSEC_PER_SEC;
        ts->tv_sec++;
    }
}
//------------------------------------------------------------------

void rt_OneStep(void);
void rt_OneStep(void)
{
  static boolean_T OverrunFlag = false;

  /* Disable interrupts here */

  /* Check for overrun */
  if (OverrunFlag) {
    rtmSetErrorStatus(carga_reno_M, "Overrun");
    return;
  }

  OverrunFlag = true;

  /* Save FPU context here (if necessary) */
  /* Re-enable timer or interrupt here */
  /* Set model inputs here */
  
  // ============================= recibe Serial===========================
  //================Falta cuadrar esto========================
    stringComplete = false;
    conti = true;
    serialFlush(fd);
    
    memset(inputCharArray, 0, sizeof(inputCharArray));
    //if (serialDataAvail (fd))
    //{
		while (conti) {
			inChar = serialGetchar(fd);
			if (inChar == 's') {
				j = 0;
				while (!stringComplete) {
					while (serialDataAvail (fd) > 0  && conti) {
						inChar = serialGetchar(fd);
						if (inChar == 'e') {
							stringComplete = true;
							conti = false;
						} else {
							inputCharArray[j] = inChar;
							j++;
						}
					}
				}
			}
		
		}
		serialFlush(fd);
		ptr = strtok(inputCharArray, delim);
		Bio_CA = ptr;
		Bio = atoi(Bio_CA);
		//vload = atoi(inputCharArray);
		ptr = strtok(NULL, delim);
		Dies_CA = ptr;
		Dies = atoi(Dies_CA);
		ptr = strtok(NULL, delim);
		//EnAlt_CA = ptr; // Esto ya no iria
		//EnAlt = atoi(EnAlt_CA); // Esto ya no iria
	//}
    
    
    //=======================================================================
    
    
    //=======================================================================
    Prefd=500;//500;
    Qrefd=3500;//3500;//2430;//3403;
    //=============== Pipes Lectura ========================
    memset(bufferPipe,0,sizeof(bufferPipe));
    //printf("CB counter %d\n",counter);
    if(fgets(bufferPipe,sizeof(bufferPipe),fp) != NULL)
    {
        Prefd = strtof(bufferPipe,&pch);
        Qrefd = strtof(pch,&pch);
        solarrad = strtof(pch,&pch);
        tempout = strtof(pch,&pch);
        
        //printf("algo en buffer para Pref y Qref\n");
        counter++;
    }
    //else{printf("File empty");}
    //======================================================
    
    TaC= tempout;//atof(tempout); //Lectura desde el txt
    Va=0.5;
    Suns=solarrad/1000.0; //atof(solarrad)/1000.0; //Lectura desde el txt
    TaK = 273 + TaC;
    IL_T1 = Isc_T1 * Suns;
    IL = IL_T1 + K0*(TaK - T1);
    I0= I0_T1*pow((TaK/T1),(3/n))*exp(-q*Vg/(n*k)*((1/TaK)-(1/T1)));
    Vt_Ta = A * k * TaK / q;
    Vc = Va/Ns;
    printf("Aqui estoy\n");
    
    for (int j=1;j<=5;j++){
        Ia=Ia- (IL - Ia - I0*( exp((Vc+Ia*Rs)/Vt_Ta) -1))/(-1 - (I0*( exp((Vc+Ia*Rs)/Vt_Ta) -1))*Rs/Vt_Ta);
    }
    
    ipv=1.5;//500;   //Proveniente de la fuente de generación PV
    //ipv=Ia;    
        
    i1=Bio/10.0;
    i3=Dies/10.0;
    
    //i3=EnAlt/10.0;
    
    
    
    tiempo=tiempo+0.0001;
    if (tiempo==0.0168) tiempo=0.0;
  
    //Carga
    set_i1(i1);
    set_i2(i3);
    //Renovables
    set_Idc_PV(ipv);
    set_Pref(Prefd);
    set_Qref(Qrefd);
    
  /* Step the model for base rate */
  carga_reno_step();

  /* Get model outputs here */
  //----- salidas-------
  //Carga
    Pm=get_Pm(); 
    Qm=get_Qm();
    Vload=get_Vload();
    potencia=get_Potencia();
    
    //Renovables
    
    
    printf("La potencia P medida es: %3.2f \n",Pm);
    printf("La potencia Q medida es: %3.2f \n",Qm);
    printf("Voltaje : %3.2f \n",Vload);
    printf ("i1: %f i2: %f i3: %f\n",i1,i2,i3);
    
    //-----------Ataque----------------
    fgets(buffera, BUFFER_SIZE, input_DoS);
    //printf("El valor del ataque String es: %s\n",buffera);
    
    int ai=atoi(buffera);
    if (ai ==1) {
        Vload=0.0;
        printf("El valor del ataque es: %d\n",ai);
    }
    printf("La valor de tensión modificada es: %3.2f \n",Vload);
    
//     if (min>Vload) min=Vload;
//     if (max<Vload) max=Vload;
    
    //=============== Pipes Envio ========================
    memset(bufferPipe,0,sizeof(bufferPipe));
    sprintf(bufferPipe,"%3.2f\t%3.2f\t%3.2f\t%3.2f\n",Pm,Qm,Vload,potencia);
    write(our_input_fifo_filestream, (void*)bufferPipe, strlen(bufferPipe));
    //======================================================
    
    //----------Serial----------------------
    //-----------Escritura-envio---------------------

    Vloada=Vload*10;
    Pma=Pm*10;
    Qma=Qm*10;
    
    //Vloada = i2;

    //Vloada = EnAlt+Dies+Bio;
    
    memset(buffer,0,sizeof(buffer));

    sprintf(buffer,"%d\n",Vloada);

    serialPuts(fd,buffer);
    
    serialFlush(fd);
    tcflush(fd, TCIOFLUSH);
  
  

  /* Indicate task complete */
  OverrunFlag = false;

  /* Disable interrupts here */
  /* Restore FPU context here (if necessary) */
  /* Enable interrupts here */
}

/*
 * The example "main" function illustrates what is required by your
 * application code to initialize, execute, and terminate the generated code.
 * Attaching rt_OneStep to a real-time clock is target specific.  This example
 * illustrates how you do this relative to initializing the model.
 */
int_T main(int_T argc, const char *argv[])
{
  /* Unused arguments */
  (void)(argc);
  (void)(argv);

  /* Initialize model */
  carga_reno_initialize();

  /* Simulating the model step behavior (in non real-time) to
   *  simulate model behavior at stop time.
   */
  while ((rtmGetErrorStatus(carga_reno_M) == (NULL)) && !rtmGetStopRequested
         (carga_reno_M)) {
    rt_OneStep();
  }

  /* Disable rt_OneStep() here */

  /* Terminate model */
  carga_reno_terminate();
  return 0;
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
