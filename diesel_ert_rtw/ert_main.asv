/*
 * File: ert_main.c
 *
 * Code generated for Simulink model 'diesel'.
 *
 * Model version                  : 1.15
 * Simulink Coder version         : 8.14 (R2018a) 06-Feb-2018
 * C/C++ source code generated on : Fri Oct  4 11:52:14 2019
 *
 * Target selection: ert.tlc
 * Embedded hardware selection: Intel->x86-64 (Windows64)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include <stddef.h>
#include <stdio.h>                     /* This ert_main.c example uses printf/fflush */
#include "diesel.h"                    /* Model's header file */
#include "rtwtypes.h"
#include <wiringSerial.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>
#include <wiringPi.h>
#include <stdint.h>
//#include <ncurses.h>
#include "libmcp3204.h"


/*
 * Associating rt_OneStep with a real-time clock or interrupt service routine
 * is what makes the generated code "real-time".  The function rt_OneStep is
 * always associated with the base rate of the model.  Subrates are managed
 * by the base rate from inside the generated code.  Enabling/disabling
 * interrupts and floating point context switches are target specific.  This
 * example code indicates where these should take place relative to executing
 * the generated code step function.  Overrun behavior should be tailored to
 * your application needs.  This example simply sets an error status in the
 * real-time model and returns from rt_OneStep.
 */

//Variables creadas por el programador
//------Entradas-------
double Pref_d=0.0;
double Qref_d=0.0;
double Vload=0.0;
double par=0.0;
double flujo=0.0;
MCP3204 ad_MCP3204;
int fileDescriptor;
char error[55];

//------Salidas--------
double Idie=0.0;
double caudal=0.0;
double vdc=0.0;
double min=5000;
double max=0.0;
double duty_cycle=0.0;
double potencia=0.0;

#define MSGISIZE 9

//Comunicacion
int  bytes_read = 0;
int pinr=0;
int var=0;
char bufferAux;
char read_buffer[MSGISIZE];   /* Buffer to store the data received              */
int var1=0;
int var2=0;
int var3=0;
char var1s[7];
char var2s[7];
char var3s[7];
int fd;
int fd2;
int i2a=0;
int caudala=0;
char buffer[8];
char buffer2[8];
double tiempo=0.0;

//===============================================================
//-------Variables para graficar
#include <math.h>
#define NUM_POINTS 100000
char * commandsForGnuplot[] = {"set title \"TITLEEEEE\"", "plot 'data.temp'"};
double xvals[NUM_POINTS];//= {1.0, 2.0, 3.0, 4.0, 5.0};
double yvals[NUM_POINTS];// = {5.0 ,3.0, 1.0, 3.0, 5.0};
FILE * temp;
FILE *	gnuplotPipe;
double in=0;
//===============================================================

//===================  Para Pipes =========================
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define OUR_INPUT_FIFO_NAME "/tmp/dataD"

int our_input_fifo_filestream = -1;
int result;
char bufferPipe[128];
//=========================================================

//--------------Para RT-----------------
#include <time.h>
#include <sched.h>
//#include <wiringPi.h>

#define NSEC_PER_SEC    1000000000

//--------------------------------------

//----------------------------Para RT------------------------------
/* using clock_nanosleep of librt */
extern int clock_nanosleep(clockid_t __clock_id, int __flags,
        __const struct timespec *__req,
        struct timespec *__rem);

/* the struct timespec consists of nanoseconds
 * and seconds. if the nanoseconds are getting
 * bigger than 1000000000 (= 1 second) the
 * variable containing seconds has to be
 * incremented and the nanoseconds decremented
 * by 1000000000.
 */
static inline void tsnorm(struct timespec *ts)
{
    while (ts->tv_nsec >= NSEC_PER_SEC) {
        ts->tv_nsec -= NSEC_PER_SEC;
        ts->tv_sec++;
    }
}
//------------------------------------------------------------------

void rt_OneStep(void);
void rt_OneStep(void)
{
  static boolean_T OverrunFlag = false;

  /* Disable interrupts here */

  /* Check for overrun */
  if (OverrunFlag) {
    rtmSetErrorStatus(diesel_M, "Overrun");
    return;
  }

  OverrunFlag = true;

  /* Save FPU context here (if necessary) */
  /* Re-enable timer or interrupt here */
  /* Set model inputs here */
  
  var=1;
    
    if (MCP3204_convert(fileDescriptor,singleEnded,CH0,&ad_MCP3204,error))
    {
        printf("Error during conversion1.\n");
        printf("%s\n",error);
        exit(1);
    }
    
    
    var1=MCP3204_getValue(ad_MCP3204);
    
    if (MCP3204_convert(fileDescriptor,singleEnded,CH1,&ad_MCP3204,error))
    {
        printf("Error during conversion1.\n");
        printf("%s\n",error);
        exit(1);
    }
    
    
    var2=MCP3204_getValue(ad_MCP3204);
    
    if (MCP3204_convert(fileDescriptor,singleEnded,CH2,&ad_MCP3204,error))
    {
        printf("Error during conversion1.\n");
        printf("%s\n",error);
        exit(1);
    }
    
    
    var3=MCP3204_getValue(ad_MCP3204);
    
    //printf("Trama de arduino: %s\n",read_buffer);
    
    /*if (var==1){
     * int q=0;
     * //Acomodar en arreglo de caracteres los datos recibidos
     * for(q=0; q<7;q++){
     * var1s[q]=read_buffer[q+1]; //Primer dato
     * //var2s[q]=read_buffer[q+10]; //Segundo dato
     * //var3s[q]=read_buffer[q+18]; //Tercer dato
     * }
     * var1=atoi(var1s);//Primer dato en numero
     * //var2=atof(var2s)/10.0; //Segundo dato en numero
     * //var3=atof(var3s)/10.0; //Segundo dato en numero
     *
     * //var3=atof(var3s)/10.0; //Segundo dato en numero
     * //printf ("El numero1  es :%d \n",var1);
     * //printf ("El numero2  es :%3.2f \n",var2);
     * //printf ("El numero3  es :%3.2f \n",var3);
     */
    
    double k=(2*170)/2248.0;
    double vx=-170-(502*2*170)/2248.0;
    k=500/873.0;
    vx=787.51;
    //double k=(2220+2150)/4095;
    //double vx=-2150;
    
    Pref_d=500;
    Qref_d=3500;
    Vload=var1*k+vx;
    //Vload=170*sin(2*3.14*60*tiempo);
    tiempo=tiempo+0.0001;
    if (tiempo>=0.017) tiempo =0;
    //Vload=Vload/10.0;
    par=0.1;//1.4;
    flujo=1000;
    
    //set_Pref_d(Pref_d);
    //set_Qref_d(Qref_d);
    set_Vload(Vload);
    //set_par(par);
    set_flujo(flujo);

  /* Step the model for base rate */
  diesel_step();

  /* Get model outputs here */
  
  //-----salidas-------
    Idie=get_I_die();
    duty_cycle=get_duty();
    potencia=get_Potencia();
    
    printf("La corriente del inversor 3 es: %3.2f \n",Idie);
    printf("La tension de la carga es : %3.2f \n",Vload);
    printf("El nivel del bus dc es: %3.2f \n",duty_cycle);
    printf("La potencia entregada a la carga es: %3.2f \n",potencia);
    
//     if (min>Idie) min=Idie;
//     if (max<Idie) max=Idie;
//     
//     printf("Valor minimo: %3.2f \n", min);
//     printf("Valor maximo: %3.2f \n", max);
    
    //=============== Pipes Envio ========================
    memset(bufferPipe,0,sizeof(bufferPipe));
    sprintf(bufferPipe,"%3.2f\t%3.2f\t%3.2f\t%3.2f\n",Idie,duty_cycle,caudal,vdc);
    write(our_input_fifo_filestream, (void*)bufferPipe, strlen(bufferPipe));
    //======================================================
    
    
    //-------------UDP-envio----------------------
    //sendm(Idie);
    //sendm(duty_cycle);
    
    //----------Serial----------------------
    //-----------Escritura-envio---------------------
    //Pma=Pm*10;
    //Qma=Qm*10;
    i2a=Idie*10;
    caudala=caudal*10;
    
    memset(buffer,0,sizeof(buffer));
    //sprintf(buffer,"p%07dq%07dv%07ds%07d\n",Pma,Qma,Vloada,soca);
    sprintf(buffer,"v%07d\n",i2a);
    //while(pinr==0){
    serialPuts(fd,buffer);
    serialFlush(fd);
    //pinr=digitalRead(2);
    //printf("El dato pin es: %d \n",pinr);
    //}
    serialFlush(fd);
    tcflush(fd, TCIOFLUSH);
    
    //Datos del caudal Bayona
    memset(buffer2,0,sizeof(buffer2));
    //sprintf(buffer,"p%07dq%07dv%07ds%07d\n",Pma,Qma,Vloada,soca);
    sprintf(buffer2,"v%07d\n",caudala);
    //while(pinr==0){
    serialPuts(fd2,buffer2);
    serialFlush(fd2);
    //pinr=digitalRead(2);
    //printf("El dato pin es: %d \n",pinr);
    //}
    serialFlush(fd2);
    tcflush(fd2, TCIOFLUSH);
    
    
    pinr=0;
    
    var=0;
    
    //-----------Grafica---------------------
    //in+=0.0001;
    //fprintf(temp, "%3.2f %3.2f %3.2f %3.2f %3.2f %3.2f \n",i1,i2,i3,Vload,Pm,Qm);
    fprintf(temp, "%3.2f %3.2f \n",Idie,Vload);
    //}

  /* Indicate task complete */
  OverrunFlag = false;

  /* Disable interrupts here */
  /* Restore FPU context here (if necessary) */
  /* Enable interrupts here */
}

/*
 * The example "main" function illustrates what is required by your
 * application code to initialize, execute, and terminate the generated code.
 * Attaching rt_OneStep to a real-time clock is target specific.  This example
 * illustrates how you do this relative to initializing the model.
 */
int_T main(int_T argc, const char *argv[])
{
  /* Unused arguments */
  (void)(argc);
  (void)(argv);

  /* Initialize model */
  diesel_initialize();

  /* Simulating the model step behavior (in non real-time) to
   *  simulate model behavior at stop time.
   */
  while ((rtmGetErrorStatus(diesel_M) == (NULL)) && !rtmGetStopRequested
         (diesel_M)) {
    rt_OneStep();
  }

  /* Disable rt_OneStep() here */

  /* Terminate model */
  diesel_terminate();
  return 0;
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
